/**
 * generated by Xtext 2.12.0
 */
package it.unige.dibris.trace_expression_language.validation;

import com.google.common.base.Objects;
import it.unige.dibris.trace_expression_language.tExp.AtomExpression;
import it.unige.dibris.trace_expression_language.tExp.EventType;
import it.unige.dibris.trace_expression_language.tExp.Expression;
import it.unige.dibris.trace_expression_language.tExp.Msg;
import it.unige.dibris.trace_expression_language.tExp.PrologExpression;
import it.unige.dibris.trace_expression_language.tExp.Term;
import it.unige.dibris.trace_expression_language.tExp.TraceExpression;
import it.unige.dibris.trace_expression_language.tExp.VariableExpression;
import it.unige.dibris.trace_expression_language.validation.AbstractTExpValidator;
import it.unige.dibris.trace_expression_language.validation.ContractivenessCheck;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.nodemodel.ICompositeNode;
import org.eclipse.xtext.nodemodel.util.NodeModelUtils;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.ValidationMessageAcceptor;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class TExpValidator extends AbstractTExpValidator {
  public final static String MainAbsence = "Main absence";
  
  public final static String Contractiveness = "Contractiveness violation";
  
  public final static String FreeVariablesNotUsed = "Free variable not used";
  
  public final static String WrongNumberArguments = "Wrong number of arguments";
  
  public final static String FreeVariables = "Free variables inside the trace expression";
  
  public final static String MessagesConsistency = "Messages must be consistent";
  
  public final static String MinMax = "Minimum must be less than maximum";
  
  public final static String OnlyOne = "Only one field is allowed";
  
  public final static String ConstraintsNotEnabled = "You have to add the \'decentralized\' field";
  
  public final static String PartitionNotEnabled = "You have to add the \'decentralized\' field";
  
  public final static String MinimalNotEnabled = "You have to add the \'decentralized\' field";
  
  public final static String MutuallyExclusive = "Mutually exclusivenesse violation";
  
  public final static String CriticalPoint = "Critical Point";
  
  public final static String RoleAbsenceInPartition = "Role not present inside the chosen partition";
  
  public final static String RangeError = "Range error";
  
  public final static String HeadNotTerminating = "Head of a concatenation which cannot terminate";
  
  @Check
  public void checkMainPresence(final TraceExpression tExp) {
    EList<Term> _terms = tExp.getTerms();
    for (final Term term : _terms) {
      if ((term.getName().equals("Main") || term.getName().equals("main"))) {
        return;
      }
    }
    EList<Term> _terms_1 = tExp.getTerms();
    for (final Term term_1 : _terms_1) {
      {
        final ICompositeNode node = NodeModelUtils.findActualNodeFor(term_1);
        ValidationMessageAcceptor _messageAcceptor = this.getMessageAcceptor();
        int _offset = node.getOffset();
        int _length = node.getLength();
        _messageAcceptor.acceptError(
          "You must specify the main term \'Main = ...\'", term_1, _offset, _length, 
          TExpValidator.MainAbsence);
      }
    }
  }
  
  @Check
  public void checkConcatenations(final TraceExpression tExp) {
    final HashMap<String, Expression> assocT = new HashMap<String, Expression>();
    EList<Term> _terms = tExp.getTerms();
    for (final Term term : _terms) {
      String _name = term.getName();
      Expression _expr = term.getExpr();
      assocT.put(_name, _expr);
    }
    double threshold = 1.0;
    if (((tExp.getThreshold() != null) && (tExp.getThreshold().size() > 0))) {
      EList<String> _threshold = tExp.getThreshold();
      String _get = _threshold.get(0);
      Double _valueOf = Double.valueOf(_get);
      threshold = (_valueOf).doubleValue();
    }
    EList<Term> _terms_1 = tExp.getTerms();
    for (final Term term_1 : _terms_1) {
      if ((term_1.getName().equals("Main") || term_1.getName().equals("main"))) {
        Expression _expr_1 = term_1.getExpr();
        HashMap<String, Expression> _hashMap = new HashMap<String, Expression>();
        this.checkConcatenationHead(_expr_1, assocT, _hashMap, threshold);
        return;
      }
    }
  }
  
  public void checkConcatenationHead(final Expression expr, final HashMap<String, Expression> assocT, final HashMap<String, Expression> assoc, final double threshold) {
    throw new Error("Unresolved compilation problems:"
      + "\nVarExpr cannot be resolved to a type."
      + "\nFilterExpr cannot be resolved to a type."
      + "\nSeqExpr cannot be resolved to a type."
      + "\nTerminalExpr cannot be resolved to a type."
      + "\nThe method or field varExpr is undefined for the type Expression"
      + "\nThe method or field filterExpr is undefined for the type Expression"
      + "\nThe method or field seqExpr is undefined for the type Expression"
      + "\nThe method or field terminalExpr is undefined for the type Expression"
      + "\nThe method or field terminalExpr is undefined for the type Expression"
      + "\nThe method or field terminalExpr is undefined for the type Expression"
      + "\nThe method or field terminalExpr is undefined for the type Expression"
      + "\nThe method or field terminalExpr is undefined for the type Expression"
      + "\nThe method or field terminalExpr is undefined for the type Expression"
      + "\nUnreachable code: The if condition can never match. It is already handled by a previous condition."
      + "\nUnreachable code: The if condition can never match. It is already handled by a previous condition."
      + "\nUnreachable code: The if condition can never match. It is already handled by a previous condition."
      + "\nUnreachable code: The if condition can never match. It is already handled by a previous condition."
      + "\nUnreachable code: The if condition can never match. It is already handled by a previous condition."
      + "\nUnreachable code: The if condition can never match. It is already handled by a previous condition."
      + "\nUnreachable code: The if condition can never match. It is already handled by a previous condition."
      + "\nbodyVar cannot be resolved"
      + "\nbodyFilter cannot be resolved"
      + "\nbodySeq cannot be resolved"
      + "\nexpr cannot be resolved"
      + "\n!== cannot be resolved"
      + "\nexpr cannot be resolved"
      + "\nterm cannot be resolved"
      + "\n!== cannot be resolved"
      + "\nterm cannot be resolved"
      + "\nname cannot be resolved"
      + "\nterm cannot be resolved"
      + "\nname cannot be resolved"
      + "\nterm cannot be resolved"
      + "\nname cannot be resolved");
  }
  
  @Check
  public void checkSeqFilterExpr(final Expression expr) {
    throw new Error("Unresolved compilation problems:"
      + "\nSeqExpr cannot be resolved to a type."
      + "\nFilterExpr cannot be resolved to a type."
      + "\nThe method or field seqExpr is undefined for the type Expression"
      + "\nThe method or field filterExpr is undefined for the type Expression");
  }
  
  @Check
  public void checkVariablesInsideConditions(final EventType eventType) {
    ArrayList<String> varsET = new ArrayList<String>();
    PrologExpression _expr = eventType.getExpr();
    this.addVariables(_expr, varsET);
    EList<PrologExpression> _exprs = eventType.getExprs();
    for (final PrologExpression expr : _exprs) {
      PrologExpression _expr_1 = eventType.getExpr();
      this.addVariables(_expr_1, varsET);
    }
    EList<Msg> _msgs = eventType.getMsgs();
    for (final Msg msg : _msgs) {
      {
        ArrayList<String> varsL = new ArrayList<String>();
        ArrayList<String> varsR = new ArrayList<String>();
        PrologExpression _content = msg.getContent();
        this.addVariables(_content, varsL);
        PrologExpression _conditions = msg.getConditions();
        this.addVariables(_conditions, varsR);
        for (final String variable : varsET) {
          if (((!varsL.contains(variable)) && (!varsR.contains(variable)))) {
            final ICompositeNode node = NodeModelUtils.findActualNodeFor(msg);
            ValidationMessageAcceptor _messageAcceptor = this.getMessageAcceptor();
            int _offset = node.getOffset();
            int _length = node.getLength();
            _messageAcceptor.acceptWarning(
              (("Free variable " + variable) + " not used"), msg, _offset, _length, 
              TExpValidator.FreeVariablesNotUsed);
            return;
          }
        }
      }
    }
  }
  
  public void addVariables(final PrologExpression expr, final List<String> vars) {
    if ((expr == null)) {
      return;
    }
    if ((expr instanceof VariableExpression)) {
      String _name = ((VariableExpression)expr).getName();
      vars.add(_name);
    } else {
      if ((expr instanceof AtomExpression)) {
        PrologExpression _terms = ((AtomExpression)expr).getTerms();
        boolean _tripleNotEquals = (_terms != null);
        if (_tripleNotEquals) {
          PrologExpression _terms_1 = ((AtomExpression)expr).getTerms();
          this.addVariables(_terms_1, vars);
        }
      } else {
        PrologExpression _left = expr.getLeft();
        boolean _tripleNotEquals_1 = (_left != null);
        if (_tripleNotEquals_1) {
          PrologExpression _left_1 = expr.getLeft();
          this.addVariables(_left_1, vars);
        }
        PrologExpression _right = expr.getRight();
        boolean _tripleNotEquals_2 = (_right != null);
        if (_tripleNotEquals_2) {
          PrologExpression _right_1 = expr.getRight();
          this.addVariables(_right_1, vars);
        }
      }
    }
  }
  
  public void checkBoundedVariables(final Expression expr, final List<String> vars) {
    throw new Error("Unresolved compilation problems:"
      + "\nVarExpr cannot be resolved to a type."
      + "\nFilterExpr cannot be resolved to a type."
      + "\nSeqExpr cannot be resolved to a type."
      + "\nThe method or field varExpr is undefined for the type Expression"
      + "\nThe method or field varExpr is undefined for the type Expression"
      + "\nThe method or field filterExpr is undefined for the type Expression"
      + "\nThe method or field filterExpr is undefined for the type Expression"
      + "\nThe method or field filterExpr is undefined for the type Expression"
      + "\nThe method or field seqExpr is undefined for the type Expression"
      + "\nThe method or field seqExpr is undefined for the type Expression"
      + "\nThe method or field seqExpr is undefined for the type Expression"
      + "\nUnreachable code: The if condition can never match. It is already handled by a previous condition."
      + "\nUnreachable code: The if condition can never match. It is already handled by a previous condition."
      + "\nUnreachable code: The if condition can never match. It is already handled by a previous condition."
      + "\nUnreachable code: The if condition can never match. It is already handled by a previous condition."
      + "\nUnreachable code: The if condition can never match. It is already handled by a previous condition."
      + "\nUnreachable code: The if condition can never match. It is already handled by a previous condition."
      + "\nbodyVar cannot be resolved"
      + "\nvariable cannot be resolved"
      + "\nbodyFilter cannot be resolved"
      + "\nfirst cannot be resolved"
      + "\nexprs cannot be resolved"
      + "\nbodySeq cannot be resolved"
      + "\nfirst cannot be resolved"
      + "\nexprs cannot be resolved");
  }
  
  public boolean areAllAsyncMsgs(final TraceExpression tExp) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field async_sender is undefined for the type Msg"
      + "\nThe method or field async_receiver is undefined for the type Msg"
      + "\n=== cannot be resolved"
      + "\n&& cannot be resolved"
      + "\n=== cannot be resolved");
  }
  
  public boolean areAllSyncMsgs(final TraceExpression tExp) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field async_sender is undefined for the type Msg"
      + "\nThe method or field async_receiver is undefined for the type Msg"
      + "\n!== cannot be resolved"
      + "\n|| cannot be resolved"
      + "\n!== cannot be resolved");
  }
  
  @Check
  public void checkMsgsConsistency(final TraceExpression tExp) {
    final boolean b1 = this.areAllAsyncMsgs(tExp);
    final boolean b2 = this.areAllSyncMsgs(tExp);
    if (((b1 && b2) || ((!b1) && (!b2)))) {
      final ICompositeNode node = NodeModelUtils.findActualNodeFor(tExp);
      ValidationMessageAcceptor _messageAcceptor = this.getMessageAcceptor();
      int _offset = node.getOffset();
      int _length = node.getLength();
      _messageAcceptor.acceptError(
        "Trace expression can contain either all sync messages or all async messages", tExp, _offset, _length, 
        TExpValidator.MessagesConsistency);
    }
  }
  
  @Check
  public void checkSequenceEventTypeConsistency(final /* SeqExpr */Object expr) {
    throw new Error("Unresolved compilation problems:"
      + "\nseqExpr cannot be resolved"
      + "\ntypeSeq cannot be resolved"
      + "\nseqExpr cannot be resolved"
      + "\ntypeSeq cannot be resolved"
      + "\nseqExpr cannot be resolved"
      + "\ntypeSeq cannot be resolved");
  }
  
  public boolean isEventTypeConsistency(final EventType eventType) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field async_sender is undefined for the type Msg"
      + "\nThe method or field async_sender is undefined for the type Msg"
      + "\nThe method or field async_receiver is undefined for the type Msg"
      + "\nThe method or field async_receiver is undefined for the type Msg"
      + "\nThe method or field sender is undefined for the type Msg"
      + "\nThe method or field sender is undefined for the type Msg"
      + "\nThe method or field receiver is undefined for the type Msg"
      + "\nThe method or field receiver is undefined for the type Msg"
      + "\n!== cannot be resolved"
      + "\nname cannot be resolved"
      + "\n!== cannot be resolved"
      + "\nname cannot be resolved"
      + "\n!== cannot be resolved"
      + "\nname cannot be resolved"
      + "\n!== cannot be resolved"
      + "\nname cannot be resolved");
  }
  
  @Check
  public void checkFreeVariables(final TraceExpression tExp) {
    ArrayList<String> freeVars = new ArrayList<String>();
    EList<Term> _terms = tExp.getTerms();
    for (final Term term : _terms) {
      if ((term.getName().equals("Main") || term.getName().equals("main"))) {
        Expression _expr = term.getExpr();
        this.checkBoundedVariables(_expr, freeVars);
        int _size = freeVars.size();
        boolean _greaterThan = (_size > 0);
        if (_greaterThan) {
          final ICompositeNode node = NodeModelUtils.findActualNodeFor(term);
          ValidationMessageAcceptor _messageAcceptor = this.getMessageAcceptor();
          int _offset = node.getOffset();
          int _length = node.getLength();
          _messageAcceptor.acceptError(
            "Trace expression cannot contain free variables", term, _offset, _length, 
            TExpValidator.FreeVariables);
        }
      }
    }
  }
  
  @Check
  public void checkPartitionCorrectlyEnabled(final TraceExpression tExp) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field partition is undefined for the type TraceExpression"
      + "\nThe method or field partition is undefined for the type TraceExpression"
      + "\nThe method or field partition is undefined for the type TraceExpression"
      + "\nThe method or field partition is undefined for the type TraceExpression"
      + "\n!== cannot be resolved"
      + "\nsize cannot be resolved"
      + "\n> cannot be resolved"
      + "\nget cannot be resolved"
      + "\nget cannot be resolved");
  }
  
  @Check
  public void checkContractiveness(final TraceExpression tExp) {
    Boolean _isContractive = ContractivenessCheck.isContractive(tExp);
    boolean _not = (!(_isContractive).booleanValue());
    if (_not) {
      EList<Term> _terms = tExp.getTerms();
      for (final Term term : _terms) {
        {
          final ICompositeNode node = NodeModelUtils.findActualNodeFor(term);
          ValidationMessageAcceptor _messageAcceptor = this.getMessageAcceptor();
          int _offset = node.getOffset();
          int _length = node.getLength();
          _messageAcceptor.acceptError(
            "Trace expression must be contractive", term, _offset, _length, 
            TExpValidator.Contractiveness);
        }
      }
    }
  }
  
  @Check
  public void checkConstraints(final /* Constraint */Object constraint) {
    throw new Error("Unresolved compilation problems:"
      + "\nSingletons cannot be resolved to a type."
      + "\nSize cannot be resolved to a type."
      + "\nCardinality cannot be resolved to a type."
      + "\nUnreachable code: The if condition can never match. It is already handled by a previous condition."
      + "\nUnreachable code: The if condition can never match. It is already handled by a previous condition."
      + "\nminSingletons cannot be resolved"
      + "\n> cannot be resolved"
      + "\nmaxSingletons cannot be resolved"
      + "\nminSize cannot be resolved"
      + "\n> cannot be resolved"
      + "\nmaxSize cannot be resolved"
      + "\nminCardinality cannot be resolved"
      + "\n> cannot be resolved"
      + "\nmaxCardinality cannot be resolved");
  }
  
  @Check
  public void checkNoDuplications(final TraceExpression tExp) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field channels is undefined for the type TraceExpression"
      + "\nsize cannot be resolved"
      + "\n> cannot be resolved");
  }
  
  @Check
  public void checkReliabilityRange(final /* Channel */Object channel) {
    throw new Error("Unresolved compilation problems:"
      + "\nreliability cannot be resolved"
      + "\nreliability cannot be resolved");
  }
  
  @Check
  public void thresholdMustBePositive(final TraceExpression tExp) {
    if ((((tExp.getThreshold() != null) && (tExp.getThreshold().size() > 0)) && (tExp.getThreshold().get(0).length() > 0))) {
      EList<String> _threshold = tExp.getThreshold();
      String _get = _threshold.get(0);
      Double d = Double.valueOf(_get);
      if ((((d).doubleValue() < 0) || ((d).doubleValue() > 1))) {
        final ICompositeNode node = NodeModelUtils.findActualNodeFor(tExp);
        ValidationMessageAcceptor _messageAcceptor = this.getMessageAcceptor();
        int _offset = node.getOffset();
        int _length = node.getLength();
        _messageAcceptor.acceptError(
          "threshold must be between 0 and 1", tExp, _offset, _length, 
          TExpValidator.RangeError);
      }
    }
  }
  
  @Check
  public void checkConstraintsOnlyIfDecentralized(final TraceExpression tExp) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field constraints is undefined for the type TraceExpression"
      + "\nThe method or field constraints is undefined for the type TraceExpression"
      + "\n!== cannot be resolved"
      + "\n&& cannot be resolved"
      + "\nsize cannot be resolved"
      + "\n> cannot be resolved");
  }
  
  @Check
  public void checkMinimalOnlyIfDecentralized(final TraceExpression tExp) {
    if (((((tExp.getDecentralized() == null) || (tExp.getDecentralized().size() == 0)) || Objects.equal(tExp.getDecentralized().get(0), "false")) && ((tExp.getMinimal() != null) && (tExp.getMinimal().size() > 0)))) {
      final ICompositeNode node = NodeModelUtils.findActualNodeFor(tExp);
      ValidationMessageAcceptor _messageAcceptor = this.getMessageAcceptor();
      int _offset = node.getOffset();
      int _length = node.getLength();
      _messageAcceptor.acceptWarning(
        "minimal will not be considered (to enable add \'decentralized: true\')", tExp, _offset, _length, 
        TExpValidator.MinimalNotEnabled);
    }
  }
  
  @Check
  public void checkConstraintsOrPartition(final TraceExpression tExp) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field constraints is undefined for the type TraceExpression"
      + "\nThe method or field constraints is undefined for the type TraceExpression"
      + "\nThe method or field partition is undefined for the type TraceExpression"
      + "\nThe method or field partition is undefined for the type TraceExpression"
      + "\nThe method or field constraints is undefined for the type TraceExpression"
      + "\nThe method or field constraints is undefined for the type TraceExpression"
      + "\nThe method or field partition is undefined for the type TraceExpression"
      + "\nThe method or field constraints is undefined for the type TraceExpression"
      + "\n!== cannot be resolved"
      + "\n&& cannot be resolved"
      + "\nsize cannot be resolved"
      + "\n> cannot be resolved"
      + "\n&& cannot be resolved"
      + "\n!== cannot be resolved"
      + "\n&& cannot be resolved"
      + "\nsize cannot be resolved"
      + "\n> cannot be resolved"
      + "\nget cannot be resolved"
      + "\nget cannot be resolved"
      + "\nget cannot be resolved"
      + "\nget cannot be resolved");
  }
  
  @Check
  public void checkMinimalOrPartition(final TraceExpression tExp) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field partition is undefined for the type TraceExpression"
      + "\nThe method or field partition is undefined for the type TraceExpression"
      + "\nThe method or field partition is undefined for the type TraceExpression"
      + "\nThe method or field partition is undefined for the type TraceExpression"
      + "\n!== cannot be resolved"
      + "\n&& cannot be resolved"
      + "\nsize cannot be resolved"
      + "\n> cannot be resolved"
      + "\n&& cannot be resolved"
      + "\n&& cannot be resolved"
      + "\nget cannot be resolved"
      + "\nget cannot be resolved");
  }
  
  @Check
  public void criticalPointsTest(final TraceExpression tExp) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field partition is undefined for the type TraceExpression"
      + "\nThe method or field partition is undefined for the type TraceExpression"
      + "\n!== cannot be resolved"
      + "\nsize cannot be resolved"
      + "\n> cannot be resolved");
  }
  
  @Check
  public void checkAllRolesInPartition(final TraceExpression tExp) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field partition is undefined for the type TraceExpression"
      + "\nThe method or field partition is undefined for the type TraceExpression"
      + "\nThe method or field roles is undefined for the type TraceExpression"
      + "\nThe method or field partition is undefined for the type TraceExpression"
      + "\n!== cannot be resolved"
      + "\n&& cannot be resolved"
      + "\nsize cannot be resolved"
      + "\n> cannot be resolved"
      + "\nget cannot be resolved"
      + "\nconstraints cannot be resolved"
      + "\nroles cannot be resolved"
      + "\nname cannot be resolved"
      + "\n== cannot be resolved"
      + "\nname cannot be resolved"
      + "\nname cannot be resolved");
  }
}
